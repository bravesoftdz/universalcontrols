unit WINTRUST;
{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      Final Delphi-Jedi (Darth) command-line units edition                }
{                                                                          }
{    Generated Date: 18/10/2006                                            }
{    Generated Time: 20:13:51                                              }
{                                                                          }
{**************************************************************************}

{
Updated by Angus Robertson, Magenta Systems Ltd, England, 20th October 2006
delphi@magsys.co.uk, http://www.magsys.co.uk/delphi/

Note only the stuff needed to check Authenticode certificates is fully
translated, lots of stuff for creating providers needs more work and is
commented out.  

}

interface
uses Windows, wcrypt2, sysutils ;


{=> WINTRUST.H <=}

{///+------------------------------------------------------------------------- }
{/// }
{/// Microsoft Windows }
{/// }
{/// Copyright (C) Microsoft Corporation, 1996 - 1999 }
{/// }
{/// File: wintrust.h }
{/// }
{/// Contents: Microsoft Internet Security Trust Provider Model }
{/// }
{/// History: 31-May-1997 pberkman created }
{/// }
{///-------------------------------------------------------------------------- }

{$IFNDEF WINTRUST_H}
{$DEFINE WINTRUST_H}

{$IFDEF _MSC_VER > 1000}
{ #pragma once }
{$ENDIF}


{$IFDEF __cplusplus}
{$ENDIF}


{$IFNDEF WIN_CERT_REVISION_1_0 // there were duplicate definitions in winbase.h}
{ # define WT_DEFINE_ALL_APIS }
{$ELSE}
{ # undef WT_DEFINE_ALL_APIS }
{$ENDIF}

{Support Type}

type
    PVOID = Pointer;
    LONG  = DWORD;
    {$IFDEF UNICODE}
      LPAWSTR = PWideChar;
    {$ELSE}
      LPAWSTR = PAnsiChar;
    {$ENDIF}

{/////////////////////////////////////////////////////////////////////////////// }
{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// Client definitions, typedefs, and prototypes }
{/// }
{/////////////////////////////////////////////////////////////////////////////// }
{/////////////////////////////////////////////////////////////////////////////// }

// GUIs from softpub.h

const

// Assigned to the pgActionID parameter of WinVerifyTrust to verify the }
// authenticity of a file/object using the Microsoft Authenticode }
// Policy Provider, }
  WINTRUST_ACTION_GENERIC_VERIFY_V2: TGUID = '{00AAC56B-CD44-11d0-8CC2-00C04FC295EE}' ;

// Assigned to the pgActionID parameter of WinVerifyTrust to dump }
// the CRYPT_PROVIDER_DATA structure to a file after calling the }
// Authenticode Policy Provider. }
  WINTRUST_ACTION_TRUSTPROVIDER_TEST: TGUID = '{573E31F8-DDBA-11d0-8CCB-00C04FC295EE}' ;


// error borrowed from JwaWinError.pas   
//
// MessageId: TRUST_E_NOSIGNATURE
//
// MessageText:
//
//  No signature was present in the subject.
//
  TRUST_E_NOSIGNATURE = HRESULT($800B0100);
  {$EXTERNALSYM TRUST_E_NOSIGNATURE}

//
// MessageId: CERT_E_EXPIRED
//
// MessageText:
//
//  A required certificate is not within its validity period when verifying against the current system clock or the timestamp in the signed file.
//
  CERT_E_EXPIRED = HRESULT($800B0101);
  {$EXTERNALSYM CERT_E_EXPIRED}

//
// MessageId: CERT_E_VALIDITYPERIODNESTING
//
// MessageText:
//
//  The validity periods of the certification chain do not nest correctly.
//
  CERT_E_VALIDITYPERIODNESTING = HRESULT($800B0102);
  {$EXTERNALSYM CERT_E_VALIDITYPERIODNESTING}

//
// MessageId: CERT_E_ROLE
//
// MessageText:
//
//  A certificate that can only be used as an end-entity is being used as a CA or visa versa.
//
  CERT_E_ROLE = HRESULT($800B0103);
  {$EXTERNALSYM CERT_E_ROLE}

//
// MessageId: CERT_E_PATHLENCONST
//
// MessageText:
//
//  A path length constraint in the certification chain has been violated.
//
  CERT_E_PATHLENCONST = HRESULT($800B0104);
  {$EXTERNALSYM CERT_E_PATHLENCONST}

//
// MessageId: CERT_E_CRITICAL
//
// MessageText:
//
//  A certificate contains an unknown extension that is marked 'critical'.
//
  CERT_E_CRITICAL = HRESULT($800B0105);
  {$EXTERNALSYM CERT_E_CRITICAL}

//
// MessageId: CERT_E_PURPOSE
//
// MessageText:
//
//  A certificate being used for a purpose other than the ones specified by its CA.
//
  CERT_E_PURPOSE = HRESULT($800B0106);
  {$EXTERNALSYM CERT_E_PURPOSE}

//
// MessageId: CERT_E_ISSUERCHAINING
//
// MessageText:
//
//  A parent of a given certificate in fact did not issue that child certificate.
//
  CERT_E_ISSUERCHAINING = HRESULT($800B0107);
  {$EXTERNALSYM CERT_E_ISSUERCHAINING}

//
// MessageId: CERT_E_MALFORMED
//
// MessageText:
//
//  A certificate is missing or has an empty value for an important field, such as a subject or issuer name.
//
  CERT_E_MALFORMED = HRESULT($800B0108);
  {$EXTERNALSYM CERT_E_MALFORMED}

//
// MessageId: CERT_E_UNTRUSTEDROOT
//
// MessageText:
//
//  A certificate chain processed, but terminated in a root certificate which is not trusted by the trust provider.
//
  CERT_E_UNTRUSTEDROOT = HRESULT($800B0109);
  {$EXTERNALSYM CERT_E_UNTRUSTEDROOT}

//
// MessageId: CERT_E_CHAINING
//
// MessageText:
//
//  A certificate chain could not be built to a trusted root authority.
//
  CERT_E_CHAINING = HRESULT($800B010A);
  {$EXTERNALSYM CERT_E_CHAINING}

//
// MessageId: TRUST_E_FAIL
//
// MessageText:
//
//  Generic trust failure.
//
  TRUST_E_FAIL = HRESULT($800B010B);
  {$EXTERNALSYM TRUST_E_FAIL}

//
// MessageId: CERT_E_REVOKED
//
// MessageText:
//
//  A certificate was explicitly revoked by its issuer.
//
  CERT_E_REVOKED = HRESULT($800B010C);
  {$EXTERNALSYM CERT_E_REVOKED}

//
// MessageId: CERT_E_UNTRUSTEDTESTROOT
//
// MessageText:
//
//  The certification path terminates with the test root which is not trusted with the current policy settings.
//
  CERT_E_UNTRUSTEDTESTROOT = HRESULT($800B010D);
  {$EXTERNALSYM CERT_E_UNTRUSTEDTESTROOT}

//
// MessageId: CERT_E_REVOCATION_FAILURE
//
// MessageText:
//
//  The revocation process could not continue - the certificate(s) could not be checked.
//
  CERT_E_REVOCATION_FAILURE = HRESULT($800B010E);
  {$EXTERNALSYM CERT_E_REVOCATION_FAILURE}

//
// MessageId: CERT_E_CN_NO_MATCH
//
// MessageText:
//
//  The certificate's CN name does not match the passed value.
//
  CERT_E_CN_NO_MATCH = HRESULT($800B010F);
  {$EXTERNALSYM CERT_E_CN_NO_MATCH}

//
// MessageId: CERT_E_WRONG_USAGE
//
// MessageText:
//
//  The certificate is not valid for the requested usage.
//
  CERT_E_WRONG_USAGE = HRESULT($800B0110);
  {$EXTERNALSYM CERT_E_WRONG_USAGE}

//
// MessageId: TRUST_E_EXPLICIT_DISTRUST
//
// MessageText:
//
//  The certificate was explicitly marked as untrusted by the user.
//
  TRUST_E_EXPLICIT_DISTRUST = HRESULT($800B0111);
  {$EXTERNALSYM TRUST_E_EXPLICIT_DISTRUST}

//
// MessageId: CERT_E_UNTRUSTEDCA
//
// MessageText:
//
//  A certification chain processed correctly, but one of the CA certificates is not trusted by the policy provider.
//
  CERT_E_UNTRUSTEDCA = HRESULT($800B0112);
  {$EXTERNALSYM CERT_E_UNTRUSTEDCA}

//
// MessageId: CERT_E_INVALID_POLICY
//
// MessageText:
//
//  The certificate has invalid policy.
//
  CERT_E_INVALID_POLICY = HRESULT($800B0113);
  {$EXTERNALSYM CERT_E_INVALID_POLICY}

//
// MessageId: CERT_E_INVALID_NAME
//
// MessageText:
//
//  The certificate has an invalid name. The name is not included in the permitted list or is explicitly excluded.
//
  CERT_E_INVALID_NAME = HRESULT($800B0114);
  {$EXTERNALSYM CERT_E_INVALID_NAME}

//
// MessageId: TRUST_E_SYSTEM_ERROR
//
// MessageText:
//
//  A system-level error occurred while verifying trust.
//
  TRUST_E_SYSTEM_ERROR = HRESULT($80096001);
  {$EXTERNALSYM TRUST_E_SYSTEM_ERROR}

//
// MessageId: TRUST_E_NO_SIGNER_CERT
//
// MessageText:
//
//  The certificate for the signer of the message is invalid or not found.
//
  TRUST_E_NO_SIGNER_CERT = HRESULT($80096002);
  {$EXTERNALSYM TRUST_E_NO_SIGNER_CERT}

//
// MessageId: TRUST_E_COUNTER_SIGNER
//
// MessageText:
//
//  One of the counter signatures was invalid.
//
  TRUST_E_COUNTER_SIGNER = HRESULT($80096003);
  {$EXTERNALSYM TRUST_E_COUNTER_SIGNER}

//
// MessageId: TRUST_E_CERT_SIGNATURE
//
// MessageText:
//
//  The signature of the certificate can not be verified.
//
  TRUST_E_CERT_SIGNATURE = HRESULT($80096004);
  {$EXTERNALSYM TRUST_E_CERT_SIGNATURE}

//
// MessageId: TRUST_E_TIME_STAMP
//
// MessageText:
//
//  The timestamp signature and/or certificate could not be verified or is malformed.
//
  TRUST_E_TIME_STAMP = HRESULT($80096005);
  {$EXTERNALSYM TRUST_E_TIME_STAMP}

//
// MessageId: TRUST_E_BAD_DIGEST
//
// MessageText:
//
//  The digital signature of the object did not verify.
//
  TRUST_E_BAD_DIGEST = HRESULT($80096010);
  {$EXTERNALSYM TRUST_E_BAD_DIGEST}

//
// MessageId: TRUST_E_BASIC_CONSTRAINTS
//
// MessageText:
//
//  A certificate's basic constraint extension has not been observed.
//
  TRUST_E_BASIC_CONSTRAINTS = HRESULT($80096019);
  {$EXTERNALSYM TRUST_E_BASIC_CONSTRAINTS}

//
// MessageId: TRUST_E_FINANCIAL_CRITERIA
//
// MessageText:
//
//  The certificate does not meet or contain the Authenticode financial extensions.
//
  TRUST_E_FINANCIAL_CRITERIA = HRESULT($8009601E);
  {$EXTERNALSYM TRUST_E_FINANCIAL_CRITERIA}
//
// MessageId: CRYPT_E_SECURITY_SETTINGS
//
// MessageText:
//
//  The cryptographic operation failed due to a local security option setting.
//
  CRYPT_E_SECURITY_SETTINGS = HRESULT($80092026);
  {$EXTERNALSYM CRYPT_E_SECURITY_SETTINGS}



{xINCLUDE <pshpack8.h>}

{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// WINTRUST_FILE_INFO Structure }
{///---------------------------------------------------------------------------- }
{/// Used when calling WinVerifyTrust against an individual file. }
{/// }
type
  WINTRUST_FILE_INFO_ = record
    cbStruct: DWORD;
    pcwszFilePath: LPCWSTR;
    hFile: THandle;
{/// 09-Dec-1997 pberkman: added }
    pgKnownSubject: PGUID;
  end {WINTRUST_FILE_INFO_};
  TWinTrustFileInfo = WINTRUST_FILE_INFO_ ;
  PWinTrustFileInfo = ^WINTRUST_FILE_INFO_ ;

{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// WINTRUST_CATALOG_INFO Structure }
{///---------------------------------------------------------------------------- }
{/// Used when calling WinVerifyTrust against a member of a Microsoft Catalog }
{/// file. }
{/// }
type
  WINTRUST_CATALOG_INFO_ = record
    cbStruct: DWORD;
    dwCatalogVersion: DWORD;
    pcwszCatalogFilePath: LPCWSTR;
    pcwszMemberTag: LPCWSTR;
    pcwszMemberFilePath: LPCWSTR;
    hMemberFile: THandle;
{/// 30-Oct-1997 pberkman: added }
    pbCalculatedFileHash: PBYTE;
    cbCalculatedFileHash: DWORD;
{/// 15-Jan-1998 pberkman: added }
    pcCatalogContext: PCCTL_CONTEXT;
  end {WINTRUST_CATALOG_INFO_};
  TWinTrustCatalogInfo = WINTRUST_CATALOG_INFO_ ;
  PWinTrustCatalogInfo = ^WINTRUST_CATALOG_INFO_ ;

{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// WINTRUST_BLOB_INFO Structure }
{///---------------------------------------------------------------------------- }
{/// Used when calling WinVerifyTrust against a memory blob. }
{/// }
type
  WINTRUST_BLOB_INFO_ = record
    cbStruct: DWORD;
    gSubject: TGUID;
    pcwszDisplayName: LPCWSTR;
    cbMemObject: DWORD;
    pbMemObject: PBYTE;
    cbMemSignedMsg: DWORD;
    pbMemSignedMsg: PBYTE;
  end {WINTRUST_BLOB_INFO_};
  TWinTrustBlobInfo = WINTRUST_BLOB_INFO_ ;
  PWinTrustBlobInfo = ^WINTRUST_BLOB_INFO_;

{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// WINTRUST_SGNR_INFO Structure }
{///---------------------------------------------------------------------------- }
{/// Used when calling WinVerifyTrust against a CMSG_SIGNER_INFO Structure }
{/// }
type
  WINTRUST_SGNR_INFO_ = record
    cbStruct: DWORD;
    pcwszDisplayName: LPCWSTR;
    psSignerInfo: PCMSG_SIGNER_INFO;
    chStores: DWORD;
    pahStores: PHCERTSTORE;
  end {WINTRUST_SGNR_INFO_};
  TWinTrustSgnrInfo = WINTRUST_SGNR_INFO_ ;
  PWinTrustSgnrInfo = ^WINTRUST_SGNR_INFO_ ;

{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// WINTRUST_CERT_INFO Structure }
{///---------------------------------------------------------------------------- }
{/// Used when calling WinVerifyTrust against a CERT_CONTEXT Structure }
{/// }
type
  WINTRUST_CERT_INFO_ = record
    cbStruct: DWORD;
    pcwszDisplayName: LPCWSTR;
    psCertContext: PCERT_CONTEXT;
    chStores: DWORD;
    pahStores: PHCERTSTORE;
{/// 17-Nov-1997 pberkman: added }
    dwFlags: DWORD;
{/// 26-Nov-1997 pberkman: added }
    psftVerifyAsOf: PFILETIME;
  end {WINTRUST_CERT_INFO_};
  TWinTrustCertInfo = WINTRUST_CERT_INFO_ ;
  PWinTrustCertInfo = ^WINTRUST_CERT_INFO_ ;

const
    WTCI_DONT_OPEN_STORES = $00000001 ; // only open dummy "root" all other are in pahStores.
    WTCI_OPEN_ONLY_ROOT = $00000002 ;


{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// WINTRUST_DATA Structure }
{///---------------------------------------------------------------------------- }
{/// Used when calling WinVerifyTrust to pass necessary information into }
{/// the Providers. }
{/// }
type
  _WINTRUST_DATA = record
    cbStruct: DWORD;                // = sizeof(WINTRUST_DATA)
    pPolicyCallbackData: PVOID;     // optional: used to pass data between the app and policy
    pSIPClientData: PVOID;          // optional: used to pass data between the app and SIP.
    dwUIChoice: DWORD;              // required: UI choice, one of WTD_UI_xx
    fdwRevocationChecks: DWORD;     // required: certificate revocation check options, one of WTD_REVOKE_xx
    dwUnionChoice: DWORD;           // required: which structure is being passed in, one of WTD_CHOICE_xx
    Info: record {union part of the original struct }
    case integer of   
        0: (pFile: PWinTrustFileInfo);           // individual file
        1: (pCatalog: PWinTrustCatalogInfo);     // member of a Catalog File
        2: (pBlob: PWinTrustBlobInfo);           // memory blob
        3: (pSgnr: PWinTrustSgnrInfo);           // signer structure only
        4: (pCert: PWinTrustCertInfo);
    end ;
// end union
    dwStateAction: DWORD;       // optional (Catalog File Processing), WTD_STATEACTION_xx
    hWVTStateData: THANDLE;     // optional (Catalog File Processing)
    pwszURLReference: LPCWSTR ; // angus ???  // optional: (future) used to determine zone.
    dwProvFlags: DWORD;         // optional:  WTD_PROV_FLAGS, etc 
    dwUIContext: DWORD;         // optional: used to determine action text in UI. WTD_UICONTEXT_xx
  end {_WINTRUST_DATA};
  TWinTrustData = _WINTRUST_DATA ;
  PWinTrustData = ^_WINTRUST_DATA ;

const

// _WINTRUST_DATA.dwUIChoice
    WTD_UI_ALL    = 1 ;
    WTD_UI_NONE   = 2 ;
    WTD_UI_NOBAD  = 3 ;
    WTD_UI_NOGOOD = 4 ;

// _WINTRUST_DATA.fdwRevocationChecks
    WTD_REVOKE_NONE       = $00000000 ;
    WTD_REVOKE_WHOLECHAIN = $00000001 ;

// _WINTRUST_DATA.dwUnionChoice
    WTD_CHOICE_FILE    = 1 ;
    WTD_CHOICE_CATALOG = 2 ;
    WTD_CHOICE_BLOB    = 3 ;
    WTD_CHOICE_SIGNER  = 4 ;
    WTD_CHOICE_CERT    = 5 ;

// _WINTRUST_DATA.dwStateAction
    WTD_STATEACTION_IGNORE  = $00000000 ;
    WTD_STATEACTION_VERIFY  = $00000001 ;
    WTD_STATEACTION_CLOSE   = $00000002 ;
    WTD_STATEACTION_AUTO_CACHE       = $00000003 ;
    WTD_STATEACTION_AUTO_CACHE_FLUSH = $00000004 ;

// 17-Feb-1998 philh: added _WINTRUST_DATA.dwProvFlags
    WTD_PROV_FLAGS_MASK     = $0000FFFF ;
    WTD_USE_IE4_TRUST_FLAG  = $00000001 ;
    WTD_NO_IE4_CHAIN_FLAG   = $00000002 ;
    WTD_NO_POLICY_USAGE_FLAG = $00000004 ;
    WTD_REVOCATION_CHECK_NONE = $00000010 ;
    WTD_REVOCATION_CHECK_END_CERT = $00000020 ;
    WTD_REVOCATION_CHECK_CHAIN    = $00000040 ;
    WTD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT = $00000080 ;
    WTD_SAFER_FLAG                 = $00000100 ;
    WTD_HASH_ONLY_FLAG             = $00000200 ;
    WTD_USE_DEFAULT_OSVER_CHECK    = $00000400 ;
    WTD_LIFETIME_SIGNING_FLAG      = $00000800 ;
    WTD_CACHE_ONLY_URL_RETRIEVAL   = $00001000 ; // affects CRL retrieval and AIA retrieval }

{/// 07-Jan-2004 tonyschr: added }
    WTD_UICONTEXT_EXECUTE = 0 ;
    WTD_UICONTEXT_INSTALL = 1 ;

{xINCLUDE <poppack.h>}


{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// WinVerifyTrust }
{///---------------------------------------------------------------------------- }
{/// Exported from WINTRUST.DLL. }
{/// Call this function to verify the trust based on a digital signer. }
{/// }
{/// pWVTData points to a WINTRUST_DATA data structure. }
{/// }
{/// WTD_SAFER_FLAG should be set in WINTRUST_DATA's dwProvFlags to enable }
{/// the following semantics for the WINTRUST_ACTION_GENERIC_VERIFY_V2 }
{/// policy provider specified in pgActionID: }
{/// - return TRUST_E_NOSIGNATURE if the subject isn't signed, has an }
{/// invalid signature or unable to find the signer certificate. }
{/// UI will never be displayed when not signed. }
{/// - ignore NO_CHECK revocation errors. Otherwise, continue to return }
{/// CERT_E_REVOCATION_FAILURE. }
{/// - search the code hash and publisher databases for the WTD_UI_NONE }
{/// dwUIChoice case. The default is to only search these databases when }
{/// UI has been enabled or user trust has been disabled. }
{/// }
{/// }
{/// Returns: }
{/// ERROR_SUCCESS If the trust is authenticated or }
{/// if the user accepted the risk. }
{/// }
{/// TRUST_E_PROVIDER_UNKNOWN there was an error loading one of the }
{/// required Providers. }
{/// }
{/// all error codes passed back are based on the Policy Provider used. }
{/// }
{/// The following errors are returned when the }
{/// WINTRUST_ACTION_GENERIC_VERIFY_V2 policy provider is specified in }
{/// pgActionID: }
{/// }
{/// TRUST_E_NOSIGNATURE (when WTD_SAFER_FLAG is set in dwProvFlags) }
{/// The subject isn't signed, has an invalid signature or unable }
{/// to find the signer certificate. All signature verification }
{/// errors will map to this error. Basically all errors except for }
{/// publisher or timestamp certificate verification. }
{/// }
{/// Call GetLastError() to get the underlying reason for not having }
{/// a valid signature. }
{/// }
{/// The following LastErrors indicate that the file doesn't have a }
{/// signature: TRUST_E_NOSIGNATURE, TRUST_E_SUBJECT_FORM_UNKNOWN or }
{/// TRUST_E_PROVIDER_UNKNOWN. }
{/// }
{/// UI will never be displayed for this case. }
{/// }
{/// TRUST_E_EXPLICIT_DISTRUST }
{/// Returned if the hash representing the subject is trusted as }
{/// AUTHZLEVELID_DISALLOWED or the publisher is in the "Disallowed" }
{/// store. Also returned if the publisher certificate is revoked. }
{/// }
{/// UI will never be displayed for this case. }
{/// }
{/// ERROR_SUCCESS }
{/// No UI unless noted below. }
{/// }
{/// Returned for the following: }
{/// - Hash representing the subject is trusted as }
{/// AUTHZLEVELID_FULLYTRUSTED }
{/// - The publisher certificate exists in the }
{/// "TrustedPublisher" store and there weren't any verification errors. }
{/// - UI was enabled and the user clicked "Yes" when asked }
{/// to install and run the signed subject. }
{/// - UI was disabled. No publisher or timestamp chain error. }
{/// }
{/// TRUST_E_SUBJECT_NOT_TRUSTED }
{/// UI was enabled and the the user clicked "No" when asked to install }
{/// and run the signed subject. }
{/// }
{/// CRYPT_E_SECURITY_SETTINGS }
{/// The subject hash or publisher wasn't explicitly trusted and }
{/// user trust wasn't allowed in the safer authenticode flags. }
{/// No UI will be displayed for this case. }
{/// }
{/// The subject is signed and its signature successfully }
{/// verified. }
{/// }
{/// Any publisher or timestamp chain error. If WTD_SAFER_FLAG wasn't set in }
{/// dwProvFlags, any signed code verification error. }
{/// }
var
  WinVerifyTrust: function(hwnd: HWND; var pgActionID: TGUID;
                                      pWVTData: Pointer): DWORD stdcall ;


{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// WinVerifyTrustEx }
{///---------------------------------------------------------------------------- }
{///*** DO NOT USE*** }
{/// }
{/// }
var
  WinVerifyTrustEx: function(hwnd: HWND; var pgActionID: TGUID;
                             var pWinTrustData: TWinTrustData): HRESULT stdcall ;


{/////////////////////////////////////////////////////////////////////////////// }
{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// Trust, Policy, and UI Provider definitions, typedefs, and prototypes }
{/// }
{/// Model: }
{/// A client wishing to validate trust through WinVerifyTrust will }
{/// select an appropriate Action ID guid for the call. }
{/// This guid is defined by each Policy Provider and represents the }
{/// functions called based on the policy for the given object. }
{/// }
{/// In this model, the Policy Provider determines which style of UI }
{/// will be shown to the user (this only applies to style, the }
{/// determination of whether UI is displayed is set by the calling client }
{/// in the UI flags member of WINTRUST_DATA). }
{/// }
{/// Since the function entry points are common (same return value and }
{/// parameters), it allows Policy Provider developers to take advantage }
{/// of existing, generic, code to fill the CRYPT_PROVIDER_DATA structure. }
{/// }
{/// This also allows the developer to simply add the specific policy they }
{/// need, then, call the generic Policy Provider - if appropriate. }
{/// }
{/////////////////////////////////////////////////////////////////////////////// }
{/////////////////////////////////////////////////////////////////////////////// }


{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// Wintrust Policy Flags }
{///---------------------------------------------------------------------------- }
{/// These are set during install and can be modified by the user }
{/// through various means. The SETREG.EXE utility (found in the Authenticode }
{/// Tools Pack) will select/deselect each of them. }
{/// }
const
  WTPF_TRUSTTEST = $00000020; {// trust any 'TEST' certificate}
const
  WTPF_TESTCANBEVALID = $00000080;
const
  WTPF_IGNOREEXPIRATION = $00000100; {// Use expiration date}
const
  WTPF_IGNOREREVOKATION = $00000200; {// Do revocation check}
const
  WTPF_OFFLINEOK_IND = $00000400; {// off-line is ok individual certs}
const
  WTPF_OFFLINEOK_COM = $00000800; {// off-line is ok commercial certs}
const
  WTPF_OFFLINEOKNBU_IND = $00001000; {// off-line is ok individual certs, no bad ui}
const
  WTPF_OFFLINEOKNBU_COM = $00002000; {// off-line is ok commercial certs, no bad ui}
const
  WTPF_VERIFY_V1_OFF = $00010000; {// turn verify of v1 certs off}
const
  WTPF_IGNOREREVOCATIONONTS = $00020000; {// ignore TimeStamp revocation checks}
const
  WTPF_ALLOWONLYPERTRUST = $00040000; {// allow only items in personal trust db.}

{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// WintrustGetRegPolicyFlags }
{///---------------------------------------------------------------------------- }
{/// This API call is exported from WINTRUST.DLL and is the recommended method }
{/// of retrieving the DWORD representing the Policy Flags. }
{/// }
var
  WintrustGetRegPolicyFlags: function(pdwPolicyFlags: PLongInt): Bool stdcall ;

{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// WintrustSetRegPolicyFlags }
{///---------------------------------------------------------------------------- }
{/// This API call is exported from WINTRUST.DLL and is the recommended method }
{/// of setting the DWORD representing the Policy Flags. MAKE SURE to call }
{/// WintrustGetRegPolicyFlags to get the current value and or/and the value }
{/// you need then call the set the flags. }
{/// }
var
  WintrustSetRegPolicyFlags: function(dwPolicyFlags: DWORD): Bool stdcall ;



{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// Trust Provider "Step" Error defines }
{///---------------------------------------------------------------------------- }
{/// Each "step" of the Trust process has an error "slot" associated with it. }
{/// If an error occurs, the "step" will assign its result to this "slot". These }
{/// errors can be any valid WINERROR.H HRESULT code. }
{/// }

{/// }
{/// step errors 0 through 20 are reserved for Authenticode specific. If }
{/// you are not calling any of the SOFTPUB.DLL (Authenticode) providers, you }
{/// may use these as needed. }
{/// }
const
  TRUSTERROR_STEP_WVTPARAMS = 0;
const
  TRUSTERROR_STEP_FILEIO = 2;
const
  TRUSTERROR_STEP_SIP = 3;
const
  TRUSTERROR_STEP_SIPSUBJINFO = 5;
const
  TRUSTERROR_STEP_CATALOGFILE = 6;
const
  TRUSTERROR_STEP_CERTSTORE = 7;
const
  TRUSTERROR_STEP_MESSAGE = 8;
const
  TRUSTERROR_STEP_MSG_SIGNERCOUNT = 9;
const
  TRUSTERROR_STEP_MSG_INNERCNTTYPE = 10;
const
  TRUSTERROR_STEP_MSG_INNERCNT = 11;
const
  TRUSTERROR_STEP_MSG_STORE = 12;
const
  TRUSTERROR_STEP_MSG_SIGNERINFO = 13;
const
  TRUSTERROR_STEP_MSG_SIGNERCERT = 14;
const
  TRUSTERROR_STEP_MSG_CERTCHAIN = 15;
const
  TRUSTERROR_STEP_MSG_COUNTERSIGINFO = 16;
const
  TRUSTERROR_STEP_MSG_COUNTERSIGCERT = 17;
const
  TRUSTERROR_STEP_VERIFY_MSGHASH = 18;
const
  TRUSTERROR_STEP_VERIFY_MSGINDIRECTDATA = 19;

{/// }
{/// step errors 30 through 37 are reserved for the ending error code for each }
{/// entry point in the Trust Model. }
{/// }
const
  TRUSTERROR_STEP_FINAL_WVTINIT = 30;
const
  TRUSTERROR_STEP_FINAL_INITPROV = 31;
const
  TRUSTERROR_STEP_FINAL_OBJPROV = 32;
const
  TRUSTERROR_STEP_FINAL_SIGPROV = 33;
const
  TRUSTERROR_STEP_FINAL_CERTPROV = 34;
const
  TRUSTERROR_STEP_FINAL_CERTCHKPROV = 35;
const
  TRUSTERROR_STEP_FINAL_POLICYPROV = 36;
const
  TRUSTERROR_STEP_FINAL_UIPROV = 37;

const
  TRUSTERROR_MAX_STEPS = 38;

{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// allocation and free function prototypes }
{///---------------------------------------------------------------------------- }
{/// }
(*
type
  = VOID*( *PFN_CPD_MEM_ALLOC)(IN DWORD CBSIZE);
type
  = VOID ( *PFN_CPD_MEM_FREE)(IN VOID*PVMEM2FREE);

type
  ( * PFN_CPD_ADD_STORE)(IN _CRYPT_PROVIDER_DATA*pProvData, IN HCERTSTORE hStore2Add); = BOOL;
    }: ///////////////////////////////////////////////////////////////////////////////;
*)
{/// }
{/// Provider function prototypes }
{///---------------------------------------------------------------------------- }
{/// }

(*

{/// }
{/// entry point for the object provider }
{/// }
    pProvData): PTYPEDEF HRESULT ( *PFN_PROVIDER_INIT_CALL)(IN OUT _CRYPT_PROVIDER_DATA;
{/// }
{/// entry point for the object provider }
{/// }
    pProvData): PTYPEDEF HRESULT ( *PFN_PROVIDER_OBJTRUST_CALL)(IN OUT _CRYPT_PROVIDER_DATA;
{/// }
{/// entry point for the Signature Provider }
{/// }
    pProvData): PTYPEDEF HRESULT ( *PFN_PROVIDER_SIGTRUST_CALL)(IN OUT _CRYPT_PROVIDER_DATA;
{/// }
{/// entry point for the Certificate Provider }
{/// }
    pProvData): PTYPEDEF HRESULT ( *PFN_PROVIDER_CERTTRUST_CALL)(IN OUT _CRYPT_PROVIDER_DATA;
{/// }
{/// entry point for the Policy Provider's final call (from the trust provider) }
{/// }
    pProvData): PTYPEDEF HRESULT ( *PFN_PROVIDER_FINALPOLICY_CALL)(IN OUT _CRYPT_PROVIDER_DATA;
{/// }
{/// entry point for the Policy Provider's "dump structure" call }
{/// }
    pProvData): PTYPEDEF HRESULT ( *PFN_PROVIDER_TESTFINALPOLICY_CALL)(IN OUT _CRYPT_PROVIDER_DATA;
{/// }
{/// entry point for the Policy Provider's clean up routine for any PRIVDATA allocated }
{/// }
    pProvData): PTYPEDEF HRESULT ( *PFN_PROVIDER_CLEANUP_CALL)(IN OUT _CRYPT_PROVIDER_DATA;
{/// }
{/// entry point for the Policy Provider's Cert Check call. This will return }
{/// true if the Trust Provider is to continue building the certificate chain. }
{/// If the PP returns FALSE, it is assumed that we have reached a "TRUSTED", }
{/// self-signed, root. it is also the CertCheck's responsibility to set the }
{/// fTrustedRoot flag in the certificate structure. }
{/// }
    pProvData, IN DWORD idxSigner, IN BOOL fCounterSignerChain, IN OPTIONAL DWORD idxCounterSigner): PTYPEDEF BOOL ( *PFN_PROVIDER_CERTCHKPOLICY_CALL)( IN _CRYPT_PROVIDER_DATA;
const
  WVT_OFFSETOF(t,f) = ((ULONG)((ULONG_PTR)(&((t* )0)->f)));
const
  WVT_ISINSTRUCT(structtypedef, = structpassedsize, member) \;
    ((WVT_OFFSETOF(structtypedef, member) < structpassedsize) ? TRUE : FALSE: Integer;
const
  WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(structtypedef, = structpassedsize, member) \;
    WVT_ISINSTRUCT(structtypedef, structpassedsize, member: Integer;
{.INCLUDE <pshpack8.h>}

*)

{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// CRYPT_PROVIDER_DATA Structure }
{///---------------------------------------------------------------------------- }
{/// Used to pass information between WinVerifyTrust and all of the Provider }
{/// calls. }
{/// }
{/// IMPORTANT: 1. All dynamically allocated members MUST use the allocation }
{/// and Add2 functions provided. }
{/// }

(*

type

  _CRYPT_PROVIDER_DATA = record
    cbStruct: DWORD;
    pWintrustData: PWINTRUST_DATA;
    fOpenedFile: Bool;
    hWndParent: HWND;
    pgActionID: PGUID;
    hProv: HCRYPTPROV;
    dwError: DWORD;
    dwRegSecuritySettings: DWORD;
    dwRegPolicySettings: DWORD;
    psPfns: P_CRYPT_PROVIDER_FUNCTIONS;
    cdwTrustStepErrors: DWORD;
    padwTrustStepErrors: PLongInt;
    chStores: DWORD;
{ HCERTSTORE*pahStores; // array of known stores (root set in WVT) root is ALWAYS #0!!! }

    dwEncoding: DWORD;
    hMsg: HCRYPTMSG;
    csSigners: DWORD;
    pasSigners: P_CRYPT_PROVIDER_SGNR;
    csProvPrivData: DWORD;
    pasProvPrivData: P_CRYPT_PROVIDER_PRIVDATA;
    dwSubjectChoice: DWORD;
    CPD_CHOICE_SIP 1 }

        pPDSip: P_PROVDATA_SIP;
  end {};


{/// 03-Oct-1997 pberkman: added }

{/// 10-Nov-1997 pberkman: added }

{/// 16-Jan-1998 pberkman: added }

{/// 17-Feb-1998 philh: added }
{/// LOWORD intialized from WINTRUST_DATA's dwProvFlags. }
    CPD_USE_NT5_CHAIN_FLAG 0x80000000 }
    CPD_REVOCATION_CHECK_NONE 0x00010000 }
    CPD_REVOCATION_CHECK_END_CERT 0x00020000 }
    CPD_REVOCATION_CHECK_CHAIN 0x00040000 }
    CPD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT 0x00080000 }

{/// 24-Feb-1998 philh: added }

{/// 20-May-1998 KeithV: added }

{/// 02-Aug-2000 philh: added }

{/// 02-Sep-2003 tonyschr: added }
    CPD_UISTATE_MODE_PROMPT 0x00000000 }
    CPD_UISTATE_MODE_BLOCK 0x00000001 }
    CPD_UISTATE_MODE_ALLOW 0x00000002 }
    CPD_UISTATE_MODE_MASK 0x00000003 }


{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// CRYPT_PROVIDER_FUNCTIONS structure }
{///---------------------------------------------------------------------------- }
{/// }
type
  _CRYPT_PROVIDER_FUNCTIONS = record
    cbStruct: DWORD;
    pfnAlloc: PFN_CPD_MEM_ALLOC;
    pfnFree: PFN_CPD_MEM_FREE;
    pfnAddStore2Chain: PFN_CPD_ADD_STORE;
    pfnAddSgnr2Chain: PFN_CPD_ADD_SGNR;
    pfnAddCert2Chain: PFN_CPD_ADD_CERT;
    pfnAddPrivData2Chain: PFN_CPD_ADD_PRIVDATA;
    pfnInitialize: PFN_PROVIDER_INIT_CALL;
    pfnObjectTrust: PFN_PROVIDER_OBJTRUST_CALL;
    pfnSignatureTrust: PFN_PROVIDER_SIGTRUST_CALL;
    pfnCertificateTrust: PFN_PROVIDER_CERTTRUST_CALL;
    pfnFinalPolicy: PFN_PROVIDER_FINALPOLICY_CALL;
    pfnCertCheckPolicy: PFN_PROVIDER_CERTCHKPOLICY_CALL;
    pfnTestFinalPolicy: PFN_PROVIDER_TESTFINALPOLICY_CALL;
    psUIpfns: P_CRYPT_PROVUI_FUNCS;
{/// 23-Jul-1997 pberkman: added }
    pfnCleanupPolicy: PFN_PROVIDER_CLEANUP_CALL;
  end {_CRYPT_PROVIDER_FUNCTIONS};
  CRYPT_PROVIDER_FUNCTIONS = _CRYPT_PROVIDER_FUNCTIONS;
  PCRYPT_PROVIDER_FUNCTIONS = ^_CRYPT_PROVIDER_FUNCTIONS;

{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// CRYPT_PROVUI_FUNCS structure }
{///---------------------------------------------------------------------------- }
{/// }

type
  ( *PFN_PROVUI_CALL)(IN HWND hWndSecurityDialog, IN _CRYPT_PROVIDER_DATA*pProvData); = BOOL;
    cbStruct: DWORD;
    psUIData: P_CRYPT_PROVUI_DATA;
    pfnOnMoreInfoClick: PFN_PROVUI_CALL;
    pfnOnMoreInfoClickDefault: PFN_PROVUI_CALL;
    pfnOnAdvancedClick: PFN_PROVUI_CALL;
    pfnOnAdvancedClickDefault: PFN_PROVUI_CALL;
  end {_CRYPT_PROVIDER_FUNCTIONS};
  CRYPT_PROVUI_FUNCS = _CRYPT_PROVIDER_FUNCTIONS;
  PCRYPT_PROVUI_FUNCS = ^_CRYPT_PROVIDER_FUNCTIONS;

{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// CRYPT_PROVUI_DATA }
{///---------------------------------------------------------------------------- }
{/// }
type
  _CRYPT_PROVUI_DATA = record
    cbStruct: DWORD;
    dwFinalError: DWORD;
    pYesButtonText: PWCHAR;
    pNoButtonText: PWCHAR;
    pMoreInfoButtonText: PWCHAR;
    pAdvancedLinkText: PWCHAR;
{/// 15-Sep-1997 pberkman: added }
{/// good: default: }
{/// "Do you want to install and run ""%1"" signed on %2 and distributed by:" }
    pCopyActionText: PWCHAR;
{/// good no time stamp: default: }
{/// "Do you want to install and run ""%1"" signed on an unknown date/time and distributed by:" }
    pCopyActionTextNoTS: PWCHAR;
{/// bad: default: }
{/// "Do you want to install and run ""%1""?" }
    pCopyActionTextNotSigned: PWCHAR;
  end {_CRYPT_PROVUI_DATA};
  CRYPT_PROVUI_DATA = _CRYPT_PROVUI_DATA;
  PCRYPT_PROVUI_DATA = ^_CRYPT_PROVUI_DATA;

{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// CRYPT_PROVIDER_SGNR structure }
{///---------------------------------------------------------------------------- }
{/// After the Signature Provider is finished there will be zero to many of these }
{/// filled out. One for each signer of the message. Also, there will be zero }
{/// to many of these filled out inside this structure. One for each counter }
{/// signer of the signer. }
{/// }
{/// IMPORTANT: 1. All dynamically allocated members MUST use allocation }
{/// and Add2 functions provided. }
{/// }
type
  _CRYPT_PROVIDER_SGNR = record
    cbStruct: DWORD;
    sftVerifyAsOf: FILETIME;
    csCertChain: DWORD;
    pasCertChain: P_CRYPT_PROVIDER_CERT;
    dwSignerType: DWORD;
{ # define SGNR_TYPE_TIMESTAMP 0x00000010 }

    psSigner: PCMSG_SIGNER_INFO;
    dwError: DWORD;
    csCounterSigners: DWORD;
    pasCounterSigners: P_CRYPT_PROVIDER_SGNR;
{/// 11-Feb-1998 philh: added }
    pChainContext: PCCERT_CHAIN_CONTEXT;
  end {_CRYPT_PROVIDER_SGNR};
  CRYPT_PROVIDER_SGNR = _CRYPT_PROVIDER_SGNR;
  PCRYPT_PROVIDER_SGNR = ^_CRYPT_PROVIDER_SGNR;

{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// CRYPT_PROVIDER_CERT structure }
{///---------------------------------------------------------------------------- }
{/// After the Signature and Certificate Providers are finished there will }
{/// be zero to many of these filled out in the CRYPT_PROVIDER_SGNR }
{/// structure. One for each certificate in the chain. }
{/// }
{/// }
type
  _CRYPT_PROVIDER_CERT = record
    cbStruct: DWORD;
    pCert: PCCERT_CONTEXT;
    fCommercial: Bool;
    fTrustedRoot: Bool;
    fSelfSigned: Bool;
    fTestCert: Bool;
    dwRevokedReason: DWORD;
    dwConfidence: DWORD;
{ # define CERT_CONFIDENCE_SIG 0x10000000 // this cert }
{ # define CERT_CONFIDENCE_TIME 0x01000000 // issuer cert }
{ # define CERT_CONFIDENCE_TIMENEST 0x00100000 // this cert }
{ # define CERT_CONFIDENCE_AUTHIDEXT 0x00010000 // this cert }
{ # define CERT_CONFIDENCE_HYGIENE 0x00001000 // this cert }
{ # define CERT_CONFIDENCE_HIGHEST 0x11111000 }

    dwError: DWORD;
    pTrustListContext: PCTL_CONTEXT;
{/// 16-Jan-1998 pberkman: added }
    fTrustListSignerCert: Bool;
{/// 25-Feb-1998 philh: added }
{/// }
{/// The following two are only applicable to Self Signed certificates }
{/// residing in a CTL. }
    pCtlContext: PCCTL_CONTEXT;
    dwCtlError: DWORD;
{/// 12-Mar-1998 philh: added }
    fIsCyclic: Bool;
{/// 12-Oct-2000 DSIE: added }
    pChainElement: PCERT_CHAIN_ELEMENT;
  end {_CRYPT_PROVIDER_CERT};
  CRYPT_PROVIDER_CERT = _CRYPT_PROVIDER_CERT;
  PCRYPT_PROVIDER_CERT = ^_CRYPT_PROVIDER_CERT;

{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// CRYPT_PROVIDER_PRIVDATA structure }
{///---------------------------------------------------------------------------- }
{/// This structure is to allow Policy Provider functions to share }
{/// POLICY SPECIFIC data between Policy Functions. }
{/// The Policy must use the pfnAddPrivateData2Chain function and }
{/// must free any data within the member before the Final Policy returns }
{/// to WVT. }
{/// To allow multiple providers to use this feature, each provider that }
{/// uses this member must set the provider ID to it's Action ID so that }
{/// the provider can find its data and ignore any other. }
{/// }
type
  _CRYPT_PROVIDER_PRIVDATA = record
    cbStruct: DWORD;
    gProviderID: GUID;
    cbProvData: DWORD;
    pvProvData: Pointer;
  end {_CRYPT_PROVIDER_PRIVDATA};
  CRYPT_PROVIDER_PRIVDATA = _CRYPT_PROVIDER_PRIVDATA;
  PCRYPT_PROVIDER_PRIVDATA = ^_CRYPT_PROVIDER_PRIVDATA;

{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// PROVDATA_SIP }
{///---------------------------------------------------------------------------- }
{/// }
type
  _PROVDATA_SIP = record
    cbStruct: DWORD;
    gSubject: GUID;
    pSip: PSIP_DISPATCH_INFO_;
    pCATSip: PSIP_DISPATCH_INFO_;
    psSipSubjectInfo: PSIP_SUBJECTINFO_;
    struct SIP_SUBJECTINFO_*psSipCATSubjectInfo: Integer;
    psIndirectData: PSIP_INDIRECT_DATA_;
  end {_PROVDATA_SIP};
  PROVDATA_SIP = _PROVDATA_SIP;
  PPROVDATA_SIP = ^_PROVDATA_SIP;

{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// structures used to register action IDs }
{///---------------------------------------------------------------------------- }
{/// }
const
  WT_CURRENT_VERSION = $00000200;

type
  _CRYPT_TRUST_REG_ENTRY = record
    cbStruct: DWORD;
    pwszDLLName: PWCHAR;
    pwszFunctionName: PWCHAR;
  end {_CRYPT_TRUST_REG_ENTRY};
  CRYPT_TRUST_REG_ENTRY = _CRYPT_TRUST_REG_ENTRY;
  PCRYPT_TRUST_REG_ENTRY = ^_CRYPT_TRUST_REG_ENTRY;

type
  _CRYPT_REGISTER_ACTIONID = record
    cbStruct: DWORD;
    sInitProvider: CRYPT_TRUST_REG_ENTRY;
    sObjectProvider: CRYPT_TRUST_REG_ENTRY;
    sSignatureProvider: CRYPT_TRUST_REG_ENTRY;
    sCertificateProvider: CRYPT_TRUST_REG_ENTRY;
    sCertificatePolicyProvider: CRYPT_TRUST_REG_ENTRY;
    sFinalPolicyProvider: CRYPT_TRUST_REG_ENTRY;
    sTestPolicyProvider: CRYPT_TRUST_REG_ENTRY;
{/// 23-Jul-1997 pberkman: added }
    sCleanupProvider: CRYPT_TRUST_REG_ENTRY;
  end {_CRYPT_REGISTER_ACTIONID};
  CRYPT_REGISTER_ACTIONID = _CRYPT_REGISTER_ACTIONID;
  PCRYPT_REGISTER_ACTIONID = ^_CRYPT_REGISTER_ACTIONID;

type
  ( *PFN_ALLOCANDFILLDEFUSAGE)(IN const char*pszUsageOID, IN _CRYPT_PROVIDER_DEFUSAGE*psDefUsage); = BOOL;
    cbStruct: DWORD;
    pgActionID: PGUID;
    pwszDllName: PWCHAR;
    pwszLoadCallbackDataFunctionName: PChar;
    pwszFreeCallbackDataFunctionName: PChar;
  end {_CRYPT_REGISTER_ACTIONID};
  CRYPT_PROVIDER_REGDEFUSAGE = _CRYPT_REGISTER_ACTIONID;
  PCRYPT_PROVIDER_REGDEFUSAGE = ^_CRYPT_REGISTER_ACTIONID;

type
  _CRYPT_PROVIDER_DEFUSAGE = record
    cbStruct: DWORD;
    gActionID: GUID;
    pDefPolicyCallbackData: PVOID;
    pDefSIPClientData: PVOID;
  end {_CRYPT_PROVIDER_DEFUSAGE};
  CRYPT_PROVIDER_DEFUSAGE = _CRYPT_PROVIDER_DEFUSAGE;
  PCRYPT_PROVIDER_DEFUSAGE = ^_CRYPT_PROVIDER_DEFUSAGE;

{$INCLUDE <poppack.h>}

{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// WINTRUST.DLL Provider defines }
{///---------------------------------------------------------------------------- }
{/// The following are definitions of the Microsoft Generic Cert Provider }
{/// }
const
  WT_PROVIDER_DLL_NAME = L'WINTRUST.DLL';
const
  WT_PROVIDER_CERTTRUST_FUNCTION = L'WintrustCertificateTrust';

{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// WintrustAddActionID }
{///---------------------------------------------------------------------------- }
{/// Adds a new Provider combination to the users' }
{/// system. Creates all necessary registry entries, etc. This should be done }
{/// during the Policy Provider's DllRegisterServer. }
{/// }
{///*** THE ONLY ONE WHO SHOULD CALL THIS IS THE POLICY PROVIDER*** }
{/// }
{/// Returns: }
{/// TRUE: No fatal errors }
{/// FALSE: Errors occured. See GetLastError() }
{/// }
var
  WintrustAddActionID: function(pgActionID: PIN GUID; 
                                fdwFlags: IN DWORD; 
                                var psProvInfo: IN CRYPT_REGISTER_ACTIONID): Bool stdcall ;

{/// By default, WintrustAddActionID doesn't return registry errors. }
{/// Set this flag to return registry errors. If FALSE is returned, }
{/// LastError is set. }
const
  WT_ADD_ACTION_ID_RET_RESULT_FLAG = $1;


{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// WintrustRemoveActionID }
{///---------------------------------------------------------------------------- }
{/// Removes the Provider action combination from the users' }
{/// system. }
{/// }
{/// Returns: }
{/// TRUE: No fatal errors }
{/// FALSE: Errors occured. See GetLastError() }
{/// }
var
  WintrustRemoveActionID: function(pgActionID: PIN GUID): Bool stdcall;

{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// WintrustLoadFunctionPointers }
{///---------------------------------------------------------------------------- }
{/// Retrieves the function entry points based on the Action ID given. }
{/// }
{/// Returns: }
{/// TRUE success. }
{/// FALSE fail. }
{/// }
var
  WintrustLoadFunctionPointers: function(var pgActionID: GUID;
                                         var pPfns: CRYPT_PROVIDER_FUNCTIONS): Bool stdcall;


{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// WintrustAddDefaultForUsage }
{///---------------------------------------------------------------------------- }
{/// Sets the default Action ID for the usage. If the provider uses this }
{/// function, and the provider requires any of the "callback" data in }
{/// WINTRUST_DATA to be filled out, it MUST completely fill out the }
{/// CRYPT_PROVIDER_REGDEFUSAGE structure. }
{/// }
{/// Returns: }
{/// TRUE success. }
{/// FALSE fail. }
{/// }
var
  WintrustAddDefaultForUsage: function(const pszUsageOID: PIN CHAR; 
                                       var psDefUsage: IN CRYPT_PROVIDER_REGDEFUSAGE): Bool stdcall; 

{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// WintrustGetDefaultForUsage }
{///---------------------------------------------------------------------------- }
{/// Retrieves the Action ID and default callback data for the specified usage }
{/// }
{/// this function must be called again with dwAction set to FREE to deallocate }
{/// }
{/// }
{/// Returns: }
{/// TRUE success. }
{/// FALSE fail. }
{/// }
const
  DWACTION_ALLOCANDFILL = 1;
const
  DWACTION_FREE = 2;
var
  WintrustGetDefaultForUsage: function(dwAction: IN DWORD; 
                                       const pszUsageOID: PIN CHAR; 
                                       var psUsage: IN OUT CRYPT_PROVIDER_DEFUSAGE): Bool stdcall; 

var
  WTHelperGetProvSignerFromChain: function(var pProvData: CRYPT_PROVIDER_DATA; 
                                           idxSigner: DWORD; 
                                           fCounterSigner: Bool; 
                                           idxCounterSigner: var LongInt): CRYPT_PROVIDER_SGNR stdcall; 
var
  WTHelperGetProvCertFromChain: function(var pSgnr: CRYPT_PROVIDER_SGNR; 
                                         idxCert: var LongInt): CRYPT_PROVIDER_CERT stdcall; 

var
  WTHelperProvDataFromStateData: function(hStateData: var THandle): CRYPT_PROVIDER_DATA stdcall; 

var
  WTHelperGetProvPrivateDataFromChain: function(var pProvData: CRYPT_PROVIDER_DATA; 
                                                var pgProviderID: GUID): PCRYPT_PROVIDER_PRIVDATA stdcall; 
var
  WTHelperCertIsSelfSigned: function(dwEncoding: DWORD; 
                                     var pCert: CERT_INFO): Bool stdcall; 

var
  WTHelperCertCheckValidSignature: function(var pProvData: CRYPT_PROVIDER_DATA): HRESULT stdcall;


{/////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// Supported ASN structures contained in WINTRUST.DLL }
{///---------------------------------------------------------------------------- }
{/// }
{$INCLUDE <pshpack8.h>}

{/// }
{/// CTL Trusted CA Lists }
{/// }
const
  szOID_TRUSTED_CODESIGNING_CA_LIST = '1.3.6.1.4.1.311.2.2.1';
const
  szOID_TRUSTED_CLIENT_AUTH_CA_LIST = '1.3.6.1.4.1.311.2.2.2';
const
  szOID_TRUSTED_SERVER_AUTH_CA_LIST = '1.3.6.1.4.1.311.2.2.3';

{/// }
{/// encode/decode OID defines }
{/// }
const
  SPC_COMMON_NAME_OBJID = szOID_COMMON_NAME;
const
  SPC_TIME_STAMP_REQUEST_OBJID = '1.3.6.1.4.1.311.3.2.1';
const
  SPC_INDIRECT_DATA_OBJID = '1.3.6.1.4.1.311.2.1.4';
const
  SPC_SP_AGENCY_INFO_OBJID = '1.3.6.1.4.1.311.2.1.10';
const
  SPC_STATEMENT_TYPE_OBJID = '1.3.6.1.4.1.311.2.1.11';
const
  SPC_SP_OPUS_INFO_OBJID = '1.3.6.1.4.1.311.2.1.12';
const
  SPC_CERT_EXTENSIONS_OBJID = '1.3.6.1.4.1.311.2.1.14';
const
  SPC_PE_IMAGE_DATA_OBJID = '1.3.6.1.4.1.311.2.1.15';
const
  SPC_RAW_FILE_DATA_OBJID = '1.3.6.1.4.1.311.2.1.18';
const
  SPC_STRUCTURED_STORAGE_DATA_OBJID = '1.3.6.1.4.1.311.2.1.19';
const
  SPC_JAVA_CLASS_DATA_OBJID = '1.3.6.1.4.1.311.2.1.20';
const
  SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID = '1.3.6.1.4.1.311.2.1.21';
const
  SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID = '1.3.6.1.4.1.311.2.1.22';
const
  SPC_CAB_DATA_OBJID = '1.3.6.1.4.1.311.2.1.25';
const
  SPC_GLUE_RDN_OBJID = '1.3.6.1.4.1.311.2.1.25'; {// obsolete!}
const
  SPC_MINIMAL_CRITERIA_OBJID = '1.3.6.1.4.1.311.2.1.26';
const
  SPC_FINANCIAL_CRITERIA_OBJID = '1.3.6.1.4.1.311.2.1.27';
const
  SPC_LINK_OBJID = '1.3.6.1.4.1.311.2.1.28';
const
  SPC_SIGINFO_OBJID = '1.3.6.1.4.1.311.2.1.30';

const
  CAT_NAMEVALUE_OBJID = '1.3.6.1.4.1.311.12.2.1';
const
  CAT_MEMBERINFO_OBJID = '1.3.6.1.4.1.311.12.2.2';


{/// }
{/// encode/decode internal defines }
{/// }
const
  SPC_SP_AGENCY_INFO_STRUCT = ((LPCSTR) 2000);
const
  SPC_MINIMAL_CRITERIA_STRUCT = ((LPCSTR) 2001);
const
  SPC_FINANCIAL_CRITERIA_STRUCT = ((LPCSTR) 2002);
const
  SPC_INDIRECT_DATA_CONTENT_STRUCT = ((LPCSTR) 2003);
const
  SPC_PE_IMAGE_DATA_STRUCT = ((LPCSTR) 2004);
const
  SPC_LINK_STRUCT = ((LPCSTR) 2005);
const
  SPC_STATEMENT_TYPE_STRUCT = ((LPCSTR) 2006);
const
  SPC_SP_OPUS_INFO_STRUCT = ((LPCSTR) 2007);
const
  SPC_CAB_DATA_STRUCT = ((LPCSTR) 2008);
const
  SPC_JAVA_CLASS_DATA_STRUCT = ((LPCSTR) 2009);

const
  SPC_SIGINFO_STRUCT = ((LPCSTR) 2130);

const
  CAT_NAMEVALUE_STRUCT = ((LPCSTR) 2221);
const
  CAT_MEMBERINFO_STRUCT = ((LPCSTR) 2222);


const
  SPC_UUID_LENGTH = 16;
type
  = BYTE SPC_UUID[SPC_UUID_LENGTH];

type
  _SPC_SERIALIZED_OBJECT = record
    ClassId: SPC_UUID;
    SerializedData: CRYPT_DATA_BLOB;
  end {_SPC_SERIALIZED_OBJECT};
  SPC_SERIALIZED_OBJECT = _SPC_SERIALIZED_OBJECT;
  PSPC_SERIALIZED_OBJECT = ^_SPC_SERIALIZED_OBJECT;

type
  SPC_SIGINFO_ = record
    dwSipVersion: DWORD;
    gSIPGuid: GUID;
    dwReserved1: DWORD;
    dwReserved2: DWORD;
    dwReserved3: DWORD;
    dwReserved4: DWORD;
    dwReserved5: DWORD;
  end {SPC_SIGINFO_};

type
  SPC_LINK_ = record
    dwLinkChoice: DWORD;
{ # define SPC_URL_LINK_CHOICE 1 }
{ # define SPC_MONIKER_LINK_CHOICE 2 }
{ # define SPC_FILE_LINK_CHOICE 3 }

        pwszUrl: PWideChar;
    Moniker: SPC_SERIALIZED_OBJECT;
    pwszFile: PWideChar;
  end {SPC_LINK_};


type
  _SPC_PE_IMAGE_DATA = record
    Flags: CRYPT_BIT_BLOB;
    pFile: PSPC_LINK;
  end {_SPC_PE_IMAGE_DATA};
  SPC_PE_IMAGE_DATA = _SPC_PE_IMAGE_DATA;
  PSPC_PE_IMAGE_DATA = ^_SPC_PE_IMAGE_DATA;

type
  _SPC_INDIRECT_DATA_CONTENT = record
    Data: CRYPT_ATTRIBUTE_TYPE_VALUE;
    DigestAlgorithm: CRYPT_ALGORITHM_IDENTIFIER;
    Digest: CRYPT_HASH_BLOB;
  end {_SPC_INDIRECT_DATA_CONTENT};
  SPC_INDIRECT_DATA_CONTENT = _SPC_INDIRECT_DATA_CONTENT;
  PSPC_INDIRECT_DATA_CONTENT = ^_SPC_INDIRECT_DATA_CONTENT;

type
  _SPC_FINANCIAL_CRITERIA = record
    fFinancialInfoAvailable: Bool;
    fMeetsCriteria: Bool;
  end {_SPC_FINANCIAL_CRITERIA};
  SPC_FINANCIAL_CRITERIA = _SPC_FINANCIAL_CRITERIA;
  PSPC_FINANCIAL_CRITERIA = ^_SPC_FINANCIAL_CRITERIA;

type
  _SPC_IMAGE = record
    pImageLink: PSPC_LINK_;
    Bitmap: CRYPT_DATA_BLOB;
    Metafile: CRYPT_DATA_BLOB;
    EnhancedMetafile: CRYPT_DATA_BLOB;
    GifFile: CRYPT_DATA_BLOB;
  end {_SPC_IMAGE};
  SPC_IMAGE = _SPC_IMAGE;
  PSPC_IMAGE = ^_SPC_IMAGE;

type
  _SPC_SP_AGENCY_INFO = record
    pPolicyInformation: PSPC_LINK_;
    pwszPolicyDisplayText: PWideChar;
    pLogoImage: PSPC_IMAGE;
    pLogoLink: PSPC_LINK_;
  end {_SPC_SP_AGENCY_INFO};
  SPC_SP_AGENCY_INFO = _SPC_SP_AGENCY_INFO;
  PSPC_SP_AGENCY_INFO = ^_SPC_SP_AGENCY_INFO;

type
  _SPC_STATEMENT_TYPE = record
    cKeyPurposeId: DWORD;
    rgpszKeyPurposeId: PPChar;
  end {_SPC_STATEMENT_TYPE};
  SPC_STATEMENT_TYPE = _SPC_STATEMENT_TYPE;
  PSPC_STATEMENT_TYPE = ^_SPC_STATEMENT_TYPE;

type
  _SPC_SP_OPUS_INFO = record
    pwszProgramName: LPCWSTR;
    pMoreInfo: PSPC_LINK_;
    pPublisherInfo: PSPC_LINK_;
  end {_SPC_SP_OPUS_INFO};
  SPC_SP_OPUS_INFO = _SPC_SP_OPUS_INFO;
  PSPC_SP_OPUS_INFO = ^_SPC_SP_OPUS_INFO;

type
  _CAT_NAMEVALUE = record
    pwszTag: PWideChar;
    fdwFlags: DWORD;
    Value: CRYPT_DATA_BLOB;
  end {_CAT_NAMEVALUE};
  CAT_NAMEVALUE = _CAT_NAMEVALUE;
  PCAT_NAMEVALUE = ^_CAT_NAMEVALUE;

type
  _CAT_MEMBERINFO = record
    pwszSubjGuid: PWideChar;
    dwCertVersion: DWORD;
  end {_CAT_MEMBERINFO};
  CAT_MEMBERINFO = _CAT_MEMBERINFO;
  PCAT_MEMBERINFO = ^_CAT_MEMBERINFO;

{$INCLUDE <poppack.h>}



{/////////////////////////////////////////////////////////////////////////////////// }
{/// }
{/// support for old calling convention:*** DO NOT USE*** }
{/// }
{$IFDEF WT_DEFINE_ALL_APIS}

type
  _WIN_CERTIFICATE = record
    dwLength: DWORD;
    wRevision: Word;
    wCertificateType: Word;
    bCertificate: Array[0..ANYSIZE_ARRAY-1] of BYTE;
  end {_WIN_CERTIFICATE};
  WIN_CERTIFICATE = _WIN_CERTIFICATE;
  LPWIN_CERTIFICATE = ^_WIN_CERTIFICATE;

const
  WIN_CERT_REVISION_1_0 = (0x0100);
const
  WIN_CERT_REVISION_2_0 = (0x0200);

const
  WIN_CERT_TYPE_X509 = (0x0001); {// bCertificate contains an X.509 Certificate}
const
  WIN_CERT_TYPE_PKCS_SIGNED_DATA = (0x0002); {// bCertificate contains a PKCS SignedData structure}
const
  WIN_CERT_TYPE_RESERVED_1 = (0x0003); {// Reserved}
const
  WIN_CERT_TYPE_TS_STACK_SIGNED = (0x0004); {// Terminal Server Protocol Stack Certificate signing}


type
  WIN_TRUST_SUBJECT = PVOID;

type
  _WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT = record
    hClientToken: THandle;
    SubjectType: PGUID;
    Subject: WIN_TRUST_SUBJECT;
  end {_WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT};
  WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT = _WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT;
  LPWIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT = ^_WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT;


type
  _WIN_TRUST_ACTDATA_SUBJECT_ONLY = record
    SubjectType: PGUID;
    Subject: WIN_TRUST_SUBJECT;
  end {_WIN_TRUST_ACTDATA_SUBJECT_ONLY};
  WIN_TRUST_ACTDATA_SUBJECT_ONLY = _WIN_TRUST_ACTDATA_SUBJECT_ONLY;
  LPWIN_TRUST_ACTDATA_SUBJECT_ONLY = ^_WIN_TRUST_ACTDATA_SUBJECT_ONLY;

{+// RawFile == 959dc450-8d9e-11cf-8736-00aa00a485eb*/ }
const
  WIN_TRUST_SUBJTYPE_RAW_FILE = \;
{

{+// PeImage == 43c9a1e0-8da0-11cf-8736-00aa00a485eb*/ }
const
  WIN_TRUST_SUBJTYPE_PE_IMAGE = \;
{


{+// JavaClass = 08ad3990-8da1-11cf-8736-00aa00a485eb*/ }
const
  WIN_TRUST_SUBJTYPE_JAVA_CLASS = \;
{
{+// Cabinet = d17c5374-a392-11cf-9df5-00aa00c184e0*/ }
const
  WIN_TRUST_SUBJTYPE_CABINET = \;
{

type
  _WIN_TRUST_SUBJECT_FILE = record
    hFile: THandle;
    lpPath: LPCWSTR;
  end {_WIN_TRUST_SUBJECT_FILE};
  WIN_TRUST_SUBJECT_FILE = _WIN_TRUST_SUBJECT_FILE;
  LPWIN_TRUST_SUBJECT_FILE = ^_WIN_TRUST_SUBJECT_FILE;

const
  WIN_TRUST_SUBJTYPE_RAW_FILEEX = \;
{

const
  WIN_TRUST_SUBJTYPE_PE_IMAGEEX = \;
{

const
  WIN_TRUST_SUBJTYPE_JAVA_CLASSEX = \;
{

const
  WIN_TRUST_SUBJTYPE_CABINETEX = \;
{

type
  _WIN_TRUST_SUBJECT_FILE_AND_DISPLAY = record
    hFile: THandle;
    lpPath: LPCWSTR;
    lpDisplayName: LPCWSTR;
  end {_WIN_TRUST_SUBJECT_FILE_AND_DISPLAY};
  WIN_TRUST_SUBJECT_FILE_AND_DISPLAY = _WIN_TRUST_SUBJECT_FILE_AND_DISPLAY;
  LPWIN_TRUST_SUBJECT_FILE_AND_DISPLAY = ^_WIN_TRUST_SUBJECT_FILE_AND_DISPLAY;

{+// OleStorage == c257e740-8da0-11cf-8736-00aa00a485eb*/ }
const
  WIN_TRUST_SUBJTYPE_OLE_STORAGE = \;
{


{+// TrustedPublisher == 66426730-8da1-11cf-8736-00aa00a485eb*/ }
const
  WIN_SPUB_ACTION_TRUSTED_PUBLISHER = \;
{

{+// NtActivateImage == 8bc96b00-8da1-11cf-8736-00aa00a485eb*/ }
const
  WIN_SPUB_ACTION_NT_ACTIVATE_IMAGE = \;
{

{+// PublishedSoftware == 64b9d180-8da2-11cf-8736-00aa00a485eb*/ }
const
  WIN_SPUB_ACTION_PUBLISHED_SOFTWARE = \;
{

type
  _WIN_SPUB_TRUSTED_PUBLISHER_DATA = record
    hClientToken: THandle;
    lpCertificate: PWIN_CERTIFICATE;
  end {_WIN_SPUB_TRUSTED_PUBLISHER_DATA};
  WIN_SPUB_TRUSTED_PUBLISHER_DATA = _WIN_SPUB_TRUSTED_PUBLISHER_DATA;
  LPWIN_SPUB_TRUSTED_PUBLISHER_DATA = ^_WIN_SPUB_TRUSTED_PUBLISHER_DATA;

{$ENDIF}

*)

{$IFDEF __cplusplus}
{$ENDIF}

{$ENDIF // WINTRUST_H}

var
  DLLLoaded: Boolean = False ; { is DLL (dynamically) loaded already? }

implementation

var
  SaveExit: pointer;
  DLLHandle: THandle;
  ErrorMode: Integer;

  procedure NewExit; far;
  begin
    ExitProc := SaveExit;
    FreeLibrary(DLLHandle)
  end {NewExit};

procedure LoadDLL;
begin
  if DLLLoaded then Exit;
  if Win32Platform < VER_PLATFORM_WIN32_NT then exit ;
  ErrorMode := SetErrorMode($8000{SEM_NoOpenFileErrorBox});
  DLLHandle := LoadLibrary('WINTRUST.DLL');
  if DLLHandle >= 32 then
  begin
    DLLLoaded := True;
    SaveExit := ExitProc;
    ExitProc := @NewExit;
    @WinVerifyTrust := GetProcAddress(DLLHandle,'WinVerifyTrust');
    Assert(@WinVerifyTrust <> nil);
    @WinVerifyTrustEx := GetProcAddress(DLLHandle,'WinVerifyTrustEx');
    Assert(@WinVerifyTrustEx <> nil);
    @WintrustGetRegPolicyFlags := GetProcAddress(DLLHandle,'WintrustGetRegPolicyFlags');
    Assert(@WintrustGetRegPolicyFlags <> nil);
    @WintrustSetRegPolicyFlags := GetProcAddress(DLLHandle,'WintrustSetRegPolicyFlags');
    Assert(@WintrustSetRegPolicyFlags <> nil);
{    @WintrustAddActionID := GetProcAddress(DLLHandle,'WintrustAddActionID');
    Assert(@WintrustAddActionID <> nil);
    @WintrustRemoveActionID := GetProcAddress(DLLHandle,'WintrustRemoveActionID');
    Assert(@WintrustRemoveActionID <> nil);
    @WintrustLoadFunctionPointers := GetProcAddress(DLLHandle,'WintrustLoadFunctionPointers');
    Assert(@WintrustLoadFunctionPointers <> nil);
    @WintrustAddDefaultForUsage := GetProcAddress(DLLHandle,'WintrustAddDefaultForUsage');
    Assert(@WintrustAddDefaultForUsage <> nil);
    @WintrustGetDefaultForUsage := GetProcAddress(DLLHandle,'WintrustGetDefaultForUsage');
    Assert(@WintrustGetDefaultForUsage <> nil);
    @WTHelperGetProvSignerFromChain := GetProcAddress(DLLHandle,'WTHelperGetProvSignerFromChain');
    Assert(@WTHelperGetProvSignerFromChain <> nil);
    @WTHelperGetProvCertFromChain := GetProcAddress(DLLHandle,'WTHelperGetProvCertFromChain');
    Assert(@WTHelperGetProvCertFromChain <> nil);
    @WTHelperProvDataFromStateData := GetProcAddress(DLLHandle,'WTHelperProvDataFromStateData');
    Assert(@WTHelperProvDataFromStateData <> nil);
    @WTHelperGetProvPrivateDataFromChain := GetProcAddress(DLLHandle,'WTHelperGetProvPrivateDataFromChain');
    Assert(@WTHelperGetProvPrivateDataFromChain <> nil);
    @WTHelperCertIsSelfSigned := GetProcAddress(DLLHandle,'WTHelperCertIsSelfSigned');
    Assert(@WTHelperCertIsSelfSigned <> nil);
    @WTHelperCertCheckValidSignature := GetProcAddress(DLLHandle,'WTHelperCertCheckValidSignature');
    }
  end
  else
  begin
    DLLLoaded := False;
    { Error: WINTRUST.DLL could not be loaded !! }
  end;
  SetErrorMode(ErrorMode)
end {LoadDLL};

begin
  LoadDLL;
end.
